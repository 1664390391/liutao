1、冒泡排序
    /*
      * 简单的冒泡排序，从小到大排序
      * 原理，从0~n-1所有数据相邻两个对比，如果后一位没有前一位大，那么就将两个数据互换，
      * 一直保证后面的是最大的，这样一轮下来最后一个就是最大的了
      * 然后同样的，在对比到 0~n-2数据，求出最后一个最大的等等
      * 第一层循环，循环所有的数据，从[0,n),由于最后一个没法和下一个比，所以比较数据是[0,n-1)
      * 第二层循环，循环未确认好的数据，从[0,n-1-m)
      */
     public void BubbleSort() {
          int i,j;
          for(i=0;i<nElems-1;i++) {
              for(j=0;j<nElems-1-i;j++) {
                   //如果前一个数比较大
                   if(arr[j].compareTo(arr[j+1])>0) {
                        //需要将j+1替换成j
                        swap(arr,j,j+1);
                   }
              }
          }
     }
结论：该算法大约做了n²/2次比较，如果数据是随机的，那么大约有一半的数据需要交换，交换的次数大约是n(4)/2
        由于常数不算在大O表示法中，所以可以认为冒泡排序运行需要O(N²)的时间级别
        外层循环N次，内部也很接近N次，意味着大约需要执行接近N²次某个基本操作